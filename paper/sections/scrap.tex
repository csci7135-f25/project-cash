From the introduction of Monads as a viable mechanism for encapsulating effects in a purely functional code base by Wadler \cite{Wadler92}, category theory has been a light illuminating future paths for new approaches to function programming. Functional Programming has lagged behind category theory in many senses. The ideas of the Monad have been around for roughly 20 years before they were introduced to computer scientists in a practical sense. Initially Monads were used to build the Haskell compiler, allowing impure computations to be "encapsulated" in a pure data structure. 

The essence of Category theory and in many senses Monads is composition. Composing effectful computations yielding a result at the leaf of this sequence. This can be seen most clearly in the syntax of programs that expose structures to developers, such as the "for...yield" construct in Scala. This basic idea of composition has been extended and made malleable by extensions to the monad such as the Free Monad described by Swierstra \cite{Swierstra08}, in his attempts to address the Expression Problem. The basic idea is to extend the Monadic structure not only to compose computations of the same "Effect Type", but to allow the composition of computations of varying effect types, using the coproduct of the type they return.

The integration of Category theory has been a great asset to the development of modular concrete interpreters and compilers. However, until recently it has not seen much use in Abstract Analysis \cite{Cousot77}. Most Abstract Interpreters rely on a monolithic approach to interpretation. This makes them rather rigid and difficult to add features to. They are composed of a generic interpreter for running the program, and static abstract domains in the sense that they cannot be combined or added to in a modular fashion. Adding an abstract domain would mean modifying existing code. 

Kiedel \cite{Keidel18} used Arrow transformers from category theory to compose Abstract Domains while preserving soundness, accompanied by pen and paper proofs, in the first iteration of his Sturdy Abstract Interpreter. Their interpreter works with the assumption that abstract domains are non-relational, preventing relational abstract analysis. In addition, the composition of domains is independent of the composition of the generic interpreter for the language being analyzed. Although the analysis domains or analysis components, as he calls them, can be reused across languages, the generic interpreter must be rewritten for each new language.

In the field of verified interpreters ITrees \cite{Xia19} are being explored for building modular semantics that can preserve proofs from their components. Itrees are a monadic data type that can be viewed as a coinductive Free Monad. Max Vistrup showed how ITrees written in Coq can be used to represent state \cite{Vistrup25}. Iris has an Effect library that has also been used to model global state, showing the parallels in expressability of ITrees and Algebraic Effects \cite{Brady13}.

Monat \cite{Monat21} developed the MOPSA abstract interpreter with a slightly different approach. MOPSA analysis relies on a project configuration file, specified by the programmer running the analysis, to instruct which domains are being used and how they are being composed. In this configuration domains are represented as DAGs or Directed Acyclic Graphs, causing evaluated expressions to cascade through each domain until a domain can perform a meaningful analysis. In other words the programmer must specify a the order of domains to be used in analysis, each used until one domain can return a value for each expression being analyzed. There was great care given to the composition of domains. It is mainly accomplished by taking the reduced product of two domains. Communication between domains is handled in part by interfaces that allow domains to communicate via queries and a generic merge function that makes states operable by multiple domains. To get around the issue of monolithic generic interpreters, MOPSA opts for a shared AST. By shared it means that each language MOPSA can analyze must be represented by their AST. This simplifies analysis but means that certain languages could be incompatible with the AST and could lead to extensions needing to made in the future. Additionally there is a computational cost to supporting a wide variety of AST nodes for each language feature of every language supported.

Recently a new approach to modularity has budded in the space. Algebraic effects and effect handlers. Most implementations have been workarounds using the syntax of modern functional languages following the style of Data types a la Carte \cite{Swierstra08}, such as Kiselyov's "Freer Monads and Extensible Effects" \cite{Kiselyov15}. However, newer languages such as Koka and Flix introduce constructs within the language for defining algebraic effects and their handlers. This reduces the syntactic overhead of working orthogonally to the languages design in order to achieve similar results. Effect handlers allow for separation between the definition of effects from their interpretation. In other words the encapsulation of syntax versus semantics. Allowing for separate definition for semantic chunks and their syntactic representations. In theory these semantic chunks could be combined to build a fully modular interpreter, either by composing concrete semantics or abstract ones, allowing for a fully modular abstract interpreter. The expression problem is partially solved by row based polymorphism as demonstrated by Hillerstrom \cite{Hillerstrom16} in "Liberating Effects with Rows and Handlers." The use of row polymorphism allows for new "types" to be introduced without changing existing code. These types are in essence effects with their own handlers defining their semantics. The distinction between an effect based approach and a monadic one is the ease of composition. Languages such as Koka can infer the effect being triggered, calling its corresponding handler. Whereas a monadic approach's implementation could be muddied by the use of complicated monad transformers. Instead of a monad transformer the differing effects representing different syntax would be handled by row polymorphism. However there are drawbacks to this approach, there has been no work on modular effect based interpretation and as a result preserving soundness would be a challenge to prove. Most likely it would require a pen and paper proof, something that could get more difficult as more semantics are supported. Additionally there is a small performance overhead as dynamic dispatch is used to create a new underlying function for each differing handler for every effect. Lastly effects are local, but relational abstract interpretation requires global invariants. This creates the challenge of trying to find a workaround to create a global effect constraints or communication. MOPSA solves this approach with it's cross domain queries allowing inter-domain communication, a unique problem that has yet to be solved with algebraic effects.