module pylang/interp

import pylang/syntax
import pylang/pyconv

import io/error
import io/filesystem
import json
import map
import scanner

// introduction beta effects
effect intI[D](i: Int): D
effect boolI[D](i: Bool): D
effect unitI[D](): D

// introduction effects
effect varI[D](e1: String): D
effect asgnI[D](x: String, v: D): D
effect plusI[D](d1: D, d2: D): D
effect minusI[D](e1: D, e2: D): D
effect notI[D](e: D): D
effect eqI[D](e1: D, e2: D): D
effect ltI[D](e1: D, e2: D): D
effect gtI[D](e1: D, e2: D): D
effect leI[D](e1: D, e2: D): D
effect geI[D](e1: D, e2: D): D
effect ifI[D](g: D, t: Expr, f: Expr): D
effect whileI[D](g: D, b: D): D
effect seqI[D](e1: D, e2: D): D
// lowering effects
effect assume[D](guard: D, e: D): D
effect assumeNot[D](guard: D, e: D): D
  
// elimination effects
interface Elimination {
  def varE(x: String): Expr
  def asgnE(x: String, v: Expr): Expr
  def plusE(e1: Expr, e2: Expr): Expr
  def minusE(e1: Expr, e2: Expr): Expr
  def notE(e: Expr): Expr
  def eqE(e1: Expr, e2: Expr): Expr
  def ltE(e1: Expr, e2: Expr): Expr
  def gtE(e1: Expr, e2: Expr): Expr
  def leE(e1: Expr, e2: Expr): Expr
  def geE(e1: Expr, e2: Expr): Expr
  def ifE(g: Expr, t: Expr, f: Expr): Expr
  def whileE(g: Expr, b: Expr): Expr
  def seqE(e1: Expr, e2: Expr): Expr
}

// unsubstantiated eval
def eval[D](e: Expr): D /
  {
    intI[D],
    boolI[D],
    unitI[D],
    varI[D],
    Elimination
  } = e match {
    case Num(i) => do intI(i)
    case Boolean(b) => do boolI(b)
    case Unit() => do unitI()
    case Plus(e1, e2) => eval(do plusE(e1, e2))
    case Minus(e1, e2) => eval(do minusE(e1, e2))
    case Not(e) => eval(do notE(e))
    case Eq(e1, e2) => eval(do eqE(e1, e2))
    case Lt(e1, e2) => eval(do ltE(e1, e2))
    case Gt(e1, e2) => eval(do gtE(e1, e2))
    case Le(e1, e2) => eval(do leE(e1, e2))
    case Ge(e1, e2) => eval(do geE(e1, e2))
    case Var(x) => do varI(x)
    case Asgn(x, v) => eval(do asgnE(x,v))
    case If(g, t, f) => eval(do ifE(g,t,f))
    case While(g, b) => eval(do whileE(g, b))
    case Seq(e1, e2) => eval(do seqE(e1, e2))
  }

