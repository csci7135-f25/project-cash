module concrete

import pylang/interp
import pylang/pyconv
import pylang/syntax

import io/error
import io/filesystem
import json
import map
import scanner

/*
def match_to_fold{prog: => Val / {Elimination}}: Val /
// def match_to_fold{prog: => Val / {Elimination}}: (Val, Map[String,Val]) /
  {
    varI[Val],
    asgnI[Val],
    plusI[Val],
    minusI[Val],
    notI[Val],
    eqI[Val],
    ltI[Val],
    gtI[Val],
    leI[Val],
    geI[Val],
    ifI[Val]
  } = {
  try {
    prog()
  }
  with Elimination {
    def varE(x) = {
      do varI(x)
    }
    def asgnE(x, v) = {
      do asgnI(x, resume(v))
    }
    def plusE(e1, e2) = {
      do plusI(resume(e1), resume(e2))
    }
    def minusE(e1, e2) = {
      do minusI(resume(e1), resume(e2))
    }
    def notE(b) = {
      do notI(resume(b))
    }
    def eqE(e1, e2) = {
      do eqI(resume(e1), resume(e2))
    }
    def ltE(e1, e2) = {
      do ltI(resume(e1), resume(e2))
    }
    def gtE(e1, e2) = {
      do gtI(resume(e1), resume(e2))
    }
    def leE(e1, e2) = {
      do leI(resume(e1), resume(e2))
    }
    def geE(e1, e2) = {
      do geI(resume(e1), resume(e2))
    }
    def ifE(g, t, f) = {
      // ifI(resume(g), resume(t), resume(f))
      resume(g) match {
        case B(true) => resume(t)
        case B(false) => resume(f)
        case I(_) => resume(f)
        case U() => resume(f)
      }
    }
    def whileE(g, b) = resume(g) match {
      // case B(true) => resume(Seq(b, While(g,b)))
      case B(true) => {resume(b); resume(While(g,b))} // neat
      case B(False) => resume(Unit())
      case I(_) => resume(Unit())
      case U() => resume(Unit())
    }
    def seqE(e1, e2) = {
      resume(e1)
      resume(e2)
    }
  }
}

// non relational state handler
def stateH(init: Map[String, Val])
  {prog: => Val / {varI[Val], asgnI[Val]}}: Val = 
  var st: Map[String, Val] = init
  try prog()
  with varI[Val] {
    def varI(n: String) =
      map::get[String, Val](st, n) match {
        case Some(v) => resume(v)
        case None() => resume(U())
      }
  }
  with asgnI[Val] {
    def asgnI(n: String, v: Val) = {
      st = st.put(n, v)
      resume(U())
    }
  }


// substantiated eval
// maybe this can return state directly
def run(e: Expr, init: Map[String, Val]): Val = {
  try {
    with stateH(init)
    with match_to_fold()
    eval(e)
  }
  with intI[Val] {
    def intI(i) = resume(I(i))
  }
  with boolI[Val] {
    def boolI(b) = resume(B(b))
  }
  with unitI[Val] {
    def unitI() = resume(U())
  }
  with plusI[Val] {
    def plusI(d1, d2) =
      (d1, d2) match {
        case (I(i1), I(i2)) => resume(I(i1 + i2))
        case _ => resume(U())
      }
  }
  with minusI[Val] {
    def minusI(d1, d2) =
      (d1, d2) match {
        case (I(i1), I(i2)) => resume(I(i1 - i2))
        case _ => resume(U())
      }
  }
  with notI[Val] {
    def notI(d) =
      d match {
        case B(true) => resume(B(false))
        case B(false) => resume(B(true))
        case _ => resume(U())
      }
  }
  with eqI[Val] {
    def eqI(d1, d2) =
      (d1, d2) match {
        case (I(i1), I(i2)) => resume(B(i1 == i2))
        case (B(b1), B(b2)) => resume(B(b1 == b2))
        case _ => resume(B(false))
      }
  }
  with ltI[Val] {
    def ltI(d1, d2) =
      (d1, d2) match {
        case (I(i1), I(i2)) => resume(B(i1 < i2))
        case (B(b1), B(b2)) => resume(B(false))
        case _ => resume(B(false))
      }
  }
  with gtI[Val] {
    def gtI(d1, d2) =
      (d1, d2) match {
        case (I(i1), I(i2)) => resume(B(i1 > i2))
        case (B(b1), B(b2)) => resume(B(false))
        case _ => resume(B(false))
      }
  }
  with leI[Val] {
    def leI(d1, d2) =
      (d1, d2) match {
        case (I(i1), I(i2)) => resume(B(i1 <= i2))
        case (B(b1), B(b2)) => resume(B(false))
        case _ => resume(B(false))
      }
  }
  with geI[Val] {
    def geI(d1, d2) =
      (d1, d2) match {
        case (I(i1), I(i2)) => resume(B(i1 >= i2))
        case (B(b1), B(b2)) => resume(B(false))
        case _ => resume(B(false))
      }
  }
}

namespace test {
  def main() = {
    with on[WrongFormat].panic
    with on[IOError].panic
    val init: Map[String, Val] = map::empty(box compareStringBytes)

    // basic arith
    val arithJson: String = filesystem::readFile("pylang/tests/testArith.json")
    feed(arithJson) {
      with scanner[Char]
      val (_, jsonVal) = build { decodeJson() }
      val arithExpr = pythonAstToExpr(jsonVal)
      println(run(arithExpr, init))
    }

    // basic if
    val ifJson: String = filesystem::readFile("pylang/tests/testIf.json")
    feed(ifJson) {
      with scanner[Char]
      val (_, jsonVal) = build { decodeJson() }
      val ifExpr = pythonAstToExpr(jsonVal)
      println(run(ifExpr, init))
    }

    // basic assign
    val asgnJson: String = filesystem::readFile("pylang/tests/testAssgn.json")
    feed(asgnJson) {
      with scanner[Char]
      val (_, jsonVal) = build { decodeJson() }
      val asgnExpr = pythonAstToExpr(jsonVal)
      println(run(asgnExpr, init))
    }
  }
}
*/

// State operations (effects used by the concrete state handler)
effect get(st: State[Val], x: String): Val
effect update(st: State[Val], x: String, v: Val): State[Val]

def match_to_fold
  { prog: => (Val, State[Val]) / {Elimination[Val]} } : (Val, State[Val]) /
  {
    unitI[Val],
    intI[Val],
    boolI[Val],
    varI[Val],
    asgnI[Val],
    plusI[Val],
    minusI[Val],
    notI[Val],
    eqI[Val],
    ltI[Val],
    gtI[Val],
    leI[Val],
    geI[Val],
    ifI[Val]
    // whileI[Val],
    // seqI[Val],
  } =
{
  try {
    prog()
  }
  with Elimination[Val] {
    def varE(st, x) = {
      do varI(st, x)
    }

    def asgnE(st, x, vExpr) = {
      val (vRes, st1) = resume((E(vExpr), st))
      do asgnI(st1, x, vRes)
    }

    def plusE(st, e1, e2) = {
      val (v1, st1) = resume((E(e1), st))
      val (v2, st2) = resume((E(e2), st1))
      do plusI(st2, v1, v2)
    }

    def minusE(st, e1, e2) = {
      val (v1, st1) = resume((E(e1), st))
      val (v2, st2) = resume((E(e2), st1))
      do minusI(st2, v1, v2)
    }

    def notE(st, e) = {
      val (v, st1) = resume((E(e), st))
      do notI(st1, v)
    }

    def eqE(st, e1, e2) = {
      val (v1, st1) = resume((E(e1), st))
      val (v2, st2) = resume((E(e2), st1))
      do eqI(st2, v1, v2)
    }

    def ltE(st, e1, e2) = {
      val (v1, st1) = resume((E(e1), st))
      val (v2, st2) = resume((E(e2), st1))
      do ltI(st2, v1, v2)
    }

    def gtE(st, e1, e2) = {
      val (v1, st1) = resume((E(e1), st))
      val (v2, st2) = resume((E(e2), st1))
      do gtI(st2, v1, v2)
    }

    def leE(st, e1, e2) = {
      val (v1, st1) = resume((E(e1), st))
      val (v2, st2) = resume((E(e2), st1))
      do leI(st2, v1, v2)
    }

    def geE(st, e1, e2) = {
      val (v1, st1) = resume((E(e1), st))
      val (v2, st2) = resume((E(e2), st1))
      do geI(st2, v1, v2)
    }

    def ifE(st, guardExpr, thenStmt, elseStmt) = {
      val (guardVal, st1) = resume((E(guardExpr), st))
      val (thenRes, st2) = resume((S(thenStmt), st1)) // cont
      val (elseRes, st3) = resume((S(elseStmt), st1)) // cont
      // do ifI(st1, guardVal, thenRes, elseRes)
      do ifI(st2, st3, guardVal, thenRes, elseRes)
    }

    def whileE(st, guardExpr, bodyStmt) = {
      val (guardVal, st1) = resume((E(guardExpr), st))
      guardVal match {
        case B(true) => {
          val (_, st2) = resume((S(bodyStmt), st1))
          resume((S(While(guardExpr, bodyStmt)), st2))
        }
        case B(false) => do unitI(st1)
        case _ => do unitI(st1)
      }
    }

    def seqE(st, s1, s2) = {
      val (_, st1) = resume((S(s1), st))
      resume((S(s2), st1))
    }
  }
}


def run(prog: Prog, init: State[Val]): (Val, State[Val]) = {
  try {
    with match_to_fold()
    eval((prog, init))
  }
  // introduction handlers produce concrete syntax::Val-like D values
  with intI[Val] { (st, i) =>
    val result = I(i)
    resume((result, st))
  }
  with boolI[Val] { (st, b) =>
    val result = B(b)
    resume((result, st))
  }
  with unitI[Val] { (st) =>
    val result = U()
    resume((result, st))
  }
  with varI[Val] { (st, x) =>
    val m: Map[String, Val] = st match {case St(a) => a}
    val v = map::get[String,Val](m, x) match {
      case Some(i) => i
      case None() => U()
    }
    resume((v, st))
  }
  with asgnI[Val] { (st, x, v) =>
    val m = st match {case St(a) => a}
    val newState = m.put(x, v)
    resume((U(), St(newState)))
  }
  with plusI[Val] { (st, d1, d2) =>
    (d1, d2) match {
      case (I(i1), I(i2)) => resume((I(i1 + i2), st))
      case _ => resume((U(), st))
    }
  }
  with minusI[Val] { (st, d1, d2) =>
    (d1, d2) match {
      case (I(i1), I(i2)) => resume((I(i1 - i2), st))
      case _ => resume((U(), st))
    }
  }

  with notI[Val] { (st, d) =>
    d match {
      case B(true) => resume((B(false), st))
      case B(false) => resume((B(true), st))
      case _ => resume((U(), st))
    }
  }

  with eqI[Val] {
    def eqI(st, d1, d2) =
      (d1, d2) match {
        case (I(i1), I(i2)) => resume((B(i1 == i2), st))
        case (B(b1), B(b2)) => resume((B(b1 == b2), st))
        case _ => resume((B(false), st))
      }
  }

  with ltI[Val] {
    def ltI(st, d1, d2) =
      (d1, d2) match {
        case (I(i1), I(i2)) => resume((B(i1 < i2), st))
        case (B(b1), B(b2)) => resume((B(false), st))
        case _ => resume((B(false), st))
      }
  }
  with gtI[Val] {
    def gtI(st, d1, d2) =
      (d1, d2) match {
        case (I(i1), I(i2)) => resume((B(i1 > i2), st))
        case (B(b1), B(b2)) => resume((B(false), st))
        case _ => resume((B(false), st))
      }
  }
  with leI[Val] {
    def leI(st, d1, d2) =
      (d1, d2) match {
        case (I(i1), I(i2)) => resume((B(i1 <= i2), st))
        case (B(b1), B(b2)) => resume((B(false), st))
        case _ => resume((B(false), st))
      }
  }
  with geI[Val] {
    def geI(st, d1, d2) =
      (d1, d2) match {
        case (I(i1), I(i2)) => resume((B(i1 >= i2), st))
        case (B(b1), B(b2)) => resume((B(false), st))
        case _ => resume((B(false), st))
      }
  }
  with ifI[Val] {(stT, stF, g, t, f) =>
    g match {
      case B(true) => resume((t, stT))
      case B(false) => resume((f, stF))
      case _ => resume((U(), stF))
    }
  }
}

namespace test {
  def main() = {
    with on[WrongFormat].panic
    with on[IOError].panic
    val init: Map[String, Val] = map::empty(box compareStringBytes)

    // basic arith
    val arithJson: String = filesystem::readFile("pylang/tests/testArith.json")
    feed(arithJson) {
      with scanner[Char]
      val (_, jsonVal) = build { decodeJson() }
      val arithExpr = pythonAstToProg(jsonVal)
      val (_, s) = run(arithExpr, St(init))
      val m = s match {case St(a) => a}
      println("--arith ex--")
      m.foreach { (k,v) => println(k); println(v)}
      println("------------")
    }

    // basic if
    val ifJson: String = filesystem::readFile("pylang/tests/testIf.json")
    feed(ifJson) {
      with scanner[Char]
      val (_, jsonVal) = build { decodeJson() }
      val ifExpr = pythonAstToProg(jsonVal)
      val (_, s) = run(ifExpr, St(init))
      val m = s match {case St(a) => a}
      println("--if ex--")
      m.foreach { (k,v) => println(k); println(v)}
      println("---------")
    }

    // basic assign
    val asgnJson: String = filesystem::readFile("pylang/tests/testAssgn.json")
    feed(asgnJson) {
      with scanner[Char]
      val (_, jsonVal) = build { decodeJson() }
      val asgnExpr = pythonAstToProg(jsonVal)
      val (_, s) = run(asgnExpr, St(init))
      val m = s match {case St(a) => a}
      println("--basic assign--")
      m.foreach { (k,v) => println(k); println(v)}
      println("----------------")
    }
  }
}
