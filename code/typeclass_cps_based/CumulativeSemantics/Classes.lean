import CumulativeSemantics.Grammar



-- Expr elmination (E) and introduction (I) classes
class CstE (σ δ : Type) where
  cst : (Prog → σ → (δ × σ)) → ConcreteValue → σ → (δ × σ)
class CstI (δ : Type) where
  cst : ConcreteValue → δ

class VarE (σ δ : Type) where
  var : (Prog → σ → (δ × σ)) → Ident → σ → (δ × σ)
class VarI (σ δ : Type) where
  var : Ident → σ → (δ × σ)

class BinopE (σ δ : Type) where
  binop : (Prog → σ → (δ × σ)) → Expr → Expr → Op → σ → (δ × σ)
class BinopI (δ : Type) where
  binop : δ → δ → Op → δ

class NegE (σ δ : Type) where
  neg : (Prog → σ → (δ × σ)) → Expr → σ →  (δ × σ)
class NegI (δ : Type) where
  neg : δ → δ

class NamedExprE (σ δ : Type) where
  namedExpr : (Prog → σ → (δ × σ)) → Ident → Expr→ σ → (δ × σ)
class NamedExprI (σ δ : Type) where
  namedExpr : Ident → δ → σ → (δ × σ)

-- Stmt elmination (E) and introduction (I) classes
class SkipE (σ δ : Type) where
  skip : (Prog → σ → (δ × σ)) → σ → (δ × σ)
class SkipI (σ δ : Type) where
  skip : σ → (σ → σ) → σ

class AssignE (σ δ : Type) where
  assign : (Prog → σ → (δ × σ)) → Ident → Expr → σ → (δ × σ)
class AssignI (σ δ : Type) where
  assign : Ident → δ → σ → (δ × σ)

class IfE (σ δ : Type) where
  if_ : (Prog → σ → (δ × σ)) → Expr → Stmt → Stmt → σ → (δ × σ)
class IfI (σ δ : Type) where
  if_ : σ → (σ → σ) → (σ → σ) → σ

class SeqE (σ δ : Type) where
  seq : (Prog → σ → (δ × σ)) → Stmt → Stmt → σ → (δ × σ)
class SeqI (σ δ : Type) where
  seq: σ → (σ → σ) → (σ → σ) → σ

-- add in while (unsure about these signatures)
class WhileE (σ δ : Type) where
  while_ : (Prog → σ → (δ × σ)) → Expr → Stmt → σ → (δ × σ)
class WhileI (σ δ : Type) where
  while_ : σ → (σ → σ) → σ


-- Not autogenerated lowering classes (domain specific functions and σ operations)
class β (δ : Type) where
  beta : ConcreteValue → δ
-- class γ (δ : Type) where
--   gamma : δ → Set ConcreteValue

class Join (σ: Type) where
  join : σ → σ → σ
infix:50 " ⊔ " => Join.join

class LatOrder (σ : Type) where
  leq : σ → σ → Bool

infix:50 " ⊑ " => LatOrder.leq

class Get (σ δ : Type) where
  get : Ident → σ → δ
class Put (σ δ : Type) where
  put : Ident → δ → σ → σ

class Assume (σ δ : Type) where
  assume : δ → σ → σ
  assumef : δ → σ → σ

class Bottom (σ : Type) where
  Bot : σ
macro "⊥" : term => `(Bottom.Bot)
