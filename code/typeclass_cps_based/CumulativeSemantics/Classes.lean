import CumulativeSemantics.Grammar



-- Expr elmination (E) and introduction (I) classes
class CstE (State δ : Type) where
  cst : (Prog → State → (δ × State)) → ConcreteValue → State → (δ × State)
class CstI (δ : Type) where
  cst : ConcreteValue → δ

class VarE (State δ : Type) where
  var : (Prog → State → (δ × State)) → Ident → State → (δ × State)
class VarI (State δ : Type) where
  var : Ident → State → (δ × State)

class BinopE (State δ : Type) where
  binop : (Prog → State → (δ × State)) → Expr → Expr → Op → State → (δ × State)
class BinopI (δ : Type) where
  binop : δ → δ → Op → δ

class NegE (State δ : Type) where
  neg : (Prog → State → (δ × State)) → Expr → State →  (δ × State)
class NegI (δ : Type) where
  neg : δ → δ

class NamedExprE (State δ : Type) where
  namedExpr : (Prog → State → (δ × State)) → Ident → Expr→ State → (δ × State)
class NamedExprI (State δ : Type) where
  namedExpr : Ident → δ → State → (δ × State)

-- Stmt elmination (E) and introduction (I) classes
class SkipE (State δ : Type) where
  skip : (Prog → State → (δ × State)) → State → (δ × State)
class SkipI (State δ : Type) where
  skip : State → (State → State) → State

class AssignE (State δ : Type) where
  assign : (Prog → State → (δ × State)) → Ident → Expr → State → (δ × State)
class AssignI (State δ : Type) where
  assign : Ident → δ → State → (δ × State)

class IfE (State δ : Type) where
  if_ : (Prog → State → (δ × State)) → Expr → Stmt → Stmt → State → (δ × State)
class IfI (State δ : Type) where
  if_ : State → (State → State) → (State → State) → State

class SeqE (State δ : Type) where
  seq : (Prog → State → (δ × State)) → Stmt → Stmt → State → (δ × State)
class SeqI (State δ : Type) where
  seq: State → (State → State) → (State → State) → State

-- add in while (unsure about these signatures)
class WhileE (State δ : Type) where
  while_ : (Prog → State → (δ × State)) → Expr → Stmt → State → (δ × State)
class WhileI (State δ : Type) where
  while_ : State → (State → State) → State


-- Not autogenerated lowering classes (domain specific functions and state operations)
class β (δ : Type) where
  beta : ConcreteValue → δ
-- class γ (δ : Type) where
--   gamma : δ → Set ConcreteValue

class Join (State: Type) where
  join : State → State → State
infix:50 " ⊔ " => Join.join

class LatOrder (State : Type) where
  leq : State → State → Bool

infix:50 " ⊑ " => LatOrder.leq

class Get (State δ : Type) where
  get : Ident → State → δ
class Put (State δ : Type) where
  put : Ident → δ → State → State

class Assume (State δ : Type) where
  assume : δ → State → State
  assumef : δ → State → State

class Bottom (State : Type) where
  Bot : State
macro "⊥" : term => `(Bottom.Bot)
