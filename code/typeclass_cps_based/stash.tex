The traditional abstract interpretation recipe has three components: concrete execution, collecting semantics, and abstract interpretation. When constructing a static analysis, a developer begins by identifying both the target language and an interesting property to be analyzed. The concrete semantics typically establish how the language runs in its native context, but in some cases are modified to highlight the chosen property. From these concrete semantics, the developer constructs the collecting semantics, which lift concrete execution to operate over all possible sets of states and values, both of which are still concrete. For any interesting language, these semantics are without fail uncomputable; however, they serve as a theoretical bridge by providing a precise specification of the property being tracked. Because of its uncomputability, many developers choose not to implement, or sometimes even define, the collecting semantics.  But, with these collecting semantics established, abstract interpretation theory enables the construction of an abstract domain that soundly approximates the collecting semantics and properly reflects the property. The language can then be analyzed using this abstract domain. Although these steps may be taken out of order and are invariably iterated upon during development, the three tiered structure of concrete, collecting, and abstract semantics remains fundamental to the methodology.

Cumulative semantics allow for this same theoretical progression while reducing the implementation burden through the stages; through the separation of concerns, distinct handlers are able to be reused. Consider the conditional $\syntax{ifnz}\;e_1\;\syntax{t}\;e_2\;\syntax{e}\;e_3$ as it moves through these semantic layers. In the concrete semantics, the elimination handler $\elim{ifnz}(e_1, e_2, e_3, \rho)$ evaluates the guard expression $e_1$ to produce $v1$, then passes both branch computations to the introduction handler $\intro{ifnz}(v_1,\tuple{e_2}{\rho'}, \tuple{e_3}{\rho'})$. The introduction handler, in the concrete domain, uses lowering handlers $\lowering{assumenz}$ and $\lowering{assumez}$ to select the appropriate branch based on whether the guard is zero, with one branch always evaluating to $\bot$. By treating the concrete domain the same as an abstract domain, the control flow structure of the two is uniform. Both branches are offered to the introduction handler, even if the concrete domain will discard one immediately.

When transitioning to collecting semantics, the elimination handler must be rewritten to operate over sets of states $P$ rather than individual states $\rho$. The collecting elimination handler becomes
\begin{mathpar}
    \elim{ifnz}(e_1, e_2, e_3, P) := \lambda\;\rec.\{\metalet{v_1}{\rec(\tuple{e_1}{\rho})}{\intro{ifnz}(v_1, \rec(\tuple{e_2}{\rho'}), \rec(\tuple{e_3}{\rho'}))} \mid \rho \in P\}
\end{mathpar}

which threads the set comprehension through the control flow logic. However, the introduction handler $\intro{ifnz}$ remains unchanged: it still receives guard values and branch results, now  applied pointwise for states in the set. The lowering handlers $\lowering{assumenz}$, $\lowering{assumez}$, and $\lowering{\sqcup}$ similarly require no change, as they already operate in the concrete domain. This reuse is possible because the cumulative abstract semantics enforce separation: elimination handlers manage control flow and state threading independently of the domain, whereas introduction and lowering handlers define domain-specific operations independently of whether they process single states or sets of states.
    
The transition from collecting to abstract semantics preserves this reuse pattern in the opposite manner. The elimination handlers from the concrete semantics can be recycled as the control flow structure remains a forwards analysis. The introduction and lowering handlers must now implement abstract domain operations rather than concrete operations. For a given abstract domain, $\intro{ifnz}$ would use abstract versions of $\lowering{assumenz}$ and $\lowering{assumez}$ that refine the value based on the guard condition, and $\lowering{\sqcup}$ would compute the join in the appropriate domain. The elimination handler has no knowledge of these domain-specific details, and requires none; it merely ensures that both branches are evaluated and the results are delivered to $\intro{ifnz}$ for the appropriate combination. The framework reduces the implementation burden across the recipe: moving from concrete to collecting semantics requires only rewriting elimination handlers while reusing all introduction handlers, and, conversely, moving from collecting to abstract semantics requires only new introduction handlers for the abstract domain while reusing the original concrete elimination handlers. Each new interpreter efficiently builds upon existing components, minimizing the need for complete reimplementation at each stage.